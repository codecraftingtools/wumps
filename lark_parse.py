#!/usr/bin/env python3

from lark import Lark
from lark.lexer import Token

from wumps.context import Context

my_grammar = r'''
    start: _expressions
    _expressions: _primary_delimiter* expression _primary_delimiter*
                | _expressions _primary_delimiter _expressions
    expression: SIMPLE_IDENTIFIER
    _primary_delimiter: _SEMICOLON
                      | _UNBRACKETED_ALIGNED_INDENT_OUTSIDE_CONTINUATION

    // Tokens generated by post-lex phase
    %declare _UNBRACKETED_ALIGNED_INDENT_OUTSIDE_CONTINUATION
    %declare _UNBRACKETED_INCREASED_INDENT_WITHOUT_CONTINUATION_MARKER
    %declare _UNBRACKETED_DECREASED_INDENT_OUTSIDE_CONTINUATION

    // Tokens to be handled and removed by post-lex phase
    NEWLINE_AND_MAYBE_INDENT: /(\n *)/
    CONTINUATION_MARKER: /\.\.\. *(--.*)?(?=\n)/

    // Non-discardable terminals
    _SEMICOLON: ";"
    COMMA: ","
    KEY: /[a-zA-Z_]+[a-zA-Z0-9_]* *:/
    OPEN_PARENTHESIS: "("
    CLOSE_PARENTHESIS: ")"
    OPEN_BRACE: "{"
    CLOSE_BRACE: "}"
    SIMPLE_IDENTIFIER: /[a-zA-Z_]+[a-zA-Z0-9_]*/
    COMPLEX_IDENTIFIER: /'(.*?)(?<!\\)'/
    STRING: /"(.*?)(?<!\\)"/
    BLOCK_STRING: /"""(([^"]+)|(\n))*"""/
    DECIMAL_INTEGER: /[-+]?[0-9_]+/
    HEXADECIMAL_INTEGER: /[-+]?0[xX][0-9a-f_]+/
    BINARY_INTEGER: /[-+]?0[bB][01_]+/
    OCTAL_INTEGER: /[-+]?0[oO][0-7_]+/
    //FLOAT: /[-+]?(?:[0-9_]+())?(?:\.+())?(?:[0-9_]+())?(?:[eE]-?\d+())?(?:\2\3|\1\4|\1\2|\2\4)/
    MEMBER_OPERATOR: "."

    // Discardable terminals
    BLANK_LINE: /\n *(?=\n)/
    FULL_LINE_COMMENT: /\n *--.*(?=\n)/
    PARTIAL_LINE_COMMENT: /--.*(?=\n)/
    INSIGNIFICANT_SPACES: / +/
    ESCAPED_NEWLINE: /\\ *\n/

    %ignore BLANK_LINE
    %ignore FULL_LINE_COMMENT
    %ignore PARTIAL_LINE_COMMENT
    %ignore INSIGNIFICANT_SPACES
    %ignore ESCAPED_NEWLINE
'''

class Indenter:
    NL_type = '_NL'
    #OPEN_PAREN_types = []
    #CLOSE_PAREN_types = []
    #INDENT_type = '_INDENT'
    #DEDENT_type = '_DEDENT'
    #tab_len = 8
    #ALIGN_INDENT = "UNBRACKETED_ALIGNED_INDENT_OUTSIDE_CONTINUATION"
    #INCR_INDENT  = "UNBRACKETED_INCREASED_INDENT_WITHOUT_CONTINUATION_MARKER"
    #DECR_INDENT  = "UNBRACKETED_DECREASED_INDENT_OUTSIDE_CONTINUATION"
    open_bracket_types  = ["OPEN_BRACE", "OPEN_PARENTHESIS"]
    close_bracket_types = ["CLOSE_BRACE", "CLOSE_PARENTHESIS"]
    def __init__(self):
        self.paren_level = 0
        self.indent_level = [0]
        self.context = Context()
        
    def handle_NL(self, token):
        if self.paren_level > 0:
            return

        yield token

        indent_str = token.rsplit('\n', 1)[1] # Tabs and spaces
        indent = indent_str.count(' ') + indent_str.count('\t') * self.tab_len

        if indent > self.indent_level[-1]:
            self.indent_level.append(indent)
            yield Token.new_borrow_pos(self.INDENT_type, indent_str, token)
        else:
            while indent < self.indent_level[-1]:
                self.indent_level.pop()
                yield Token.new_borrow_pos(self.DEDENT_type, indent_str, token)

            assert indent == self.indent_level[-1], '%s != %s' % (indent, self.indent_level[-1])

    def handle_newline_and_maybe_indent(self, token):
        new_indent = token[1:]
        if (not self.context.is_bracketed() and
            not self.context.starting_continuation() and 
            not self.context.in_continuation() and
            len(new_indent) == self.context.current_indent()):
            yield Token.new_borrow_pos(
                "_UNBRACKETED_ALIGNED_INDENT_OUTSIDE_CONTINUATION",
                token, token)
        elif (not self.context.is_bracketed() and
              not self.context.starting_continuation() and 
              len(new_indent) > self.context.current_indent()):
            self.context.push_indent(
                amount=len(new_indent), is_continuation=False)
            yield Token.new_borrow_pos(
                "_UNBRACKETED_INCREASED_INDENT_WITHOUT_CONTINUATION_MARKER",
                token, token)
        elif (not self.context.is_bracketed() and
              not self.context.starting_continuation() and 
              not self.context.in_continuation() and
              len(new_indent) < self.context.current_indent()):
            if len(new_indent) > self.context.previous_indent():
                # partial unindent
                self.context.pop_indent()
                self.context.push_indent(
                    amount=len(new_indent), is_continuation=True)
                yield Token.new_borrow_pos(
                    "_UNBRACKETED_DECREASED_INDENT_OUTSIDE_CONTINUATION",
                    token, token)
            else:
                self.context.pop_indent()
                yield Token.new_borrow_pos(
                    "_UNBRACKETED_DECREASED_INDENT_OUTSIDE_CONTINUATION",
                    "", token)
        elif (self.context.is_bracketed()):
            # Ignore BRACKETED_NEWLINE
            pass
        elif (not self.context.is_bracketed() and
              self.context.starting_continuation() and
              len(new_indent) > self.context.current_indent()):
            # UNBRACKETED_INCREASED_INDENT_AFTER_CONTINUATION_MARKER
            self.context.push_indent(
                amount=len(new_indent), is_continuation=True)
        elif (not self.context.is_bracketed() and
              self.context.in_continuation() and
              len(new_indent) == self.context.current_indent()):
            # UNBRACKETED_ALIGNED_INDENT_INSIDE_CONTINUATION
            pass
        elif (not self.context.is_bracketed() and
              not self.context.starting_continuation() and
              self.context.in_continuation() and
              len(new_indent) < self.context.current_indent()):
            # UNBRACKETED_DECREASED_INDENT_INSIDE_CONTINUATION
            if len(new_indent) > self.context.previous_indent():
                # partial unindent
                self.context.pop_indent()
                self.context.push_indent(
                    amount=len(new_indent), is_continuation=True)
            else:
                self.context.pop_indent()
        else:
            yield token
        
    def process(self, stream):
        for token in stream:
            if token.type in self.open_bracket_types:
                self.context.nest_bracket()
                yield token
            elif token.type in self.close_bracket_types:
                self.context.unnest_bracket()
                yield token
            elif token.type == "CONTINUATION_MARKER":
                if not self.context.is_bracketed():
                    self.context.start_continuation()
                else:
                    yield token
            elif token.type == "NEWLINE_AND_MAYBE_INDENT":
                for t in self.handle_newline_and_maybe_indent(token):
                    yield t
            else:
                yield token
            #continue
            #if token.type == self.NL_type:
            #    for t in self.handle_NL(token):
            #        yield t
            #else:
            #    yield token
            # 
            #if token.type in self.OPEN_PAREN_types:
            #    self.paren_level += 1
            #elif token.type in self.CLOSE_PAREN_types:
            #    self.paren_level -= 1
            #    assert self.paren_level >= 0

        while self.context.current_indent() > 0:
            self.context.pop_indent()
            yield Token("_UNBRACKETED_DECREASED_INDENT_OUTSIDE_CONTINUATION","")
            
        #while len(self.indent_level) > 1:
        #    self.indent_level.pop()
        #    yield Token(self.DEDENT_type, '')
        # 
        #assert self.indent_level == [0], self.indent_level

    # XXX Hack for ContextualLexer. Maybe there's a more elegant solution?
    @property
    def always_accept(self):
        return (self.NL_type,)

def print_lex(parser, text):
    generator = parser.lex(text)
    for token in generator:
        if token.type in [
                "NEWLINE_AND_MAYBE_INDENT",
                "_UNBRACKETED_ALIGNED_INDENT_OUTSIDE_CONTINUATION",
                "_UNBRACKETED_INCREASED_INDENT_WITHOUT_CONTINUATION_MARKER",
                "_UNBRACKETED_DECREASED_INDENT_OUTSIDE_CONTINUATION",
        ]:
            print(token.type)
        else:
            print(token.type,token)
    
def main():
    #parser = Lark(my_grammar, postlex=TreeIndenter())
    parser = Lark(my_grammar, lexer='standard', postlex=Indenter())
    text = """
;; a;; 
b;;
  c;"""
    text = """a
 b;{};
e
{
a ...

}
 f
  c;"""
    text = """
a
b;;c;;

d
e"""
    tree = parser.parse(text)
    print(tree.pretty(),end="")
    #print_lex(parser, text)
    
if __name__ == '__main__':
    main()
